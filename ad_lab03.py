# -*- coding: utf-8 -*-
"""AD_Lab03.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QVuyXUw4OZRb6lKjBRpB0OGzVIQr5VgF

#Lab 03
Date-14-01-2025
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
#write code to remove warnings
import warnings
warnings.filterwarnings('ignore')

df = pd.read_csv('Japan_life_expectancy.csv')

"""Q1) Practical: Load the dataset from the provided file and display the first five rows."""

print("Dataset Shape:", df.shape)
print("First few rows of the dataset:")
print(df.head(5))

df.columns

"""Q2) Display the summary statistics (mean, median, standard deviation, etc.) for some numerical columns in the dataset."""

print("\nDescriptive Statistics:")
print(df.describe())

"""Q3)Identify and display the data types of each column in the dataset. What are the types of variables (categorical, numerical, etc.)?"""

print("\nData Types:")
print(df.dtypes)
numerical_cols = df.select_dtypes(include=np.number).columns

"""Q4)Write a script to check for missing values in each column and
display the count of missing values.
"""

print("\nMissing Values:")
print(df.isnull().sum())

"""Q5)Handle missing values by imputing them with the mean for
numerical columns. Show the code and the updated dataset.
"""

for col in numerical_cols:
    mean_val = df[col].mean()
    df[col].fillna(mean_val, inplace=True)
# Verify that there are no more missing values in numerical columns
print("\nMissing Values After Imputation:")
print(df[numerical_cols].isnull().sum())

"""Q6)Calculate the correlation matrix for all numerical attributes.
Write the code to generate and display the matrix.
"""

# Select only numeric columns for correlation
numeric_df = df.select_dtypes(include=[np.number])
# Calculate the correlation matrix
correlation = numeric_df.corr()
print(correlation)

"""Q7)Identify features that have a correlation value higher than 0.8
or lower than -0.8.
"""

def highlight_highly_correlated_pairs(correlation_matrix, threshold=0.8):
    high_corr_pairs = pd.DataFrame(columns=["Feature 1", "Feature 2", "Correlation"])
    for col1 in correlation_matrix.columns:
        for col2 in correlation_matrix.index:
            if col1 != col2:  # Avoid self-correlation
                corr = correlation_matrix.loc[col1, col2]
                if abs(corr) > threshold:
                    # Check if the pair (col1, col2) is already in the DataFrame (or col2,col1)
                    existing_pairs = [(row["Feature 1"], row["Feature 2"]) for _, row in high_corr_pairs.iterrows()]
                    if (col1, col2) not in existing_pairs and (col2, col1) not in existing_pairs:
                        new_row = pd.DataFrame({"Feature 1": [col1], "Feature 2": [col2], "Correlation": [corr]})
                        high_corr_pairs = pd.concat([high_corr_pairs, new_row], ignore_index=True)
    return high_corr_pairs
# Find highly correlated pairs
highly_correlated_pairs = highlight_highly_correlated_pairs(correlation, threshold=0.8)
# Display the result
print("Highly Correlated Pairs:")
print(highly_correlated_pairs)

"""Q8)Write the code to create a heatmap that visualizes the
correlation matrix between the numerical attributes.
"""

# Plot the heatmap
plt.figure(figsize=(16, 8))
sns.heatmap(correlation, annot=True, cmap='coolwarm', linewidths=0.5)
plt.title('Correlation Heatmap')
plt.show()

"""Q9)Generate histograms for each numerical attribute in the
dataset. Write the code to plot these distributions.
"""

# Determine the number of rows and columns for the grid
num_cols = len(numerical_cols)
num_rows = (num_cols + 2) // 3  # Ensure we have 3 columns, adjust as needed
# Create a figure and a grid of subplots, with a smaller figure size
fig, axes = plt.subplots(nrows=num_rows, ncols=8, figsize=(10, 2 * num_rows))  # Adjusted figsize
# Flatten the axes array
axes = axes.flatten()
# Generate histograms for each numerical column
for i, col in enumerate(numerical_cols):
    sns.histplot(df[col], kde=True, ax=axes[i])
    axes[i].set_title(f'Histogram of {col}', fontsize=6)  # Smaller font size
    axes[i].set_xlabel(col, fontsize=4)  # Smaller font size
    axes[i].set_ylabel('Frequency', fontsize=6)  # Smaller font size
    axes[i].tick_params(axis='both', which='major', labelsize=5)  # Smaller tick labels
# Hide any unused subplots
for j in range(i + 1, len(axes)):
    axes[j].set_visible(False)
# Adjust the layout to prevent overlapping
plt.tight_layout()
# Show the plot
plt.show()

"""Q10)Write a script to create a box plot for one numerical attribute
in the dataset. What do the whiskers and outliers represent in the plot?
"""

attribute = 'Life_expectancy'
# Create the box plot
plt.figure(figsize=(4, 3))
sns.boxplot(x=df[attribute])
plt.title(f'Box Plot of {attribute}')
plt.xlabel(attribute)
plt.show()

"""About the Whiskers and Outliers

**Box:**
The box represents the interquartile range (IQR), which contains the middle 50% of the data.
The bottom of the box is the 25th percentile (Q1).
The line inside the box is the median (50th percentile or Q2).
The top of the box is the 75th percentile (Q3).

**Whiskers:**
The whiskers extend from the box to indicate the range of the data, excluding potential outliers.
Typically, the whiskers extend to the farthest data point within 1.5 times the IQR from the edge of the box.



*   Lower Whisker: Q1 - 1.5 * IQR
*   Upper Whisker: Q3 + 1.5 * IQR



  

**Outliers:**
Outliers are data points that fall outside the whiskers. They are plotted as individual points.
Outliers are considered unusually high or low values compared to the rest of the dataset.

Q11)Generate box plots for multiple numerical attributes in a single
plot to compare their distributions. Write the code and describe the
differences in spread and central tendencies.
"""

# Set the figure size
plt.figure(figsize=(8, 4))
# Melt the DataFrame to long format for easier plotting
df_melted = pd.melt(df[numerical_cols])
# Create the box plot using seaborn
sns.boxplot(x='variable', y='value', data=df_melted)
# Rotate x-axis labels for better readability
plt.xticks(rotation=90)
# Set title and labels
plt.title('Box Plots of Multiple Numerical Attributes')
plt.xlabel('Numerical Attributes')
plt.ylabel('Values')
# Show the plot
plt.show()

"""Q12)Write a script to create a box plot for a numerical attribute and
identify the outliers. What thresholds define these outliers?
"""

# Identify outliers
Q1 = df[attribute].quantile(0.25)
Q3 = df[attribute].quantile(0.75)
IQR = Q3 - Q1
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR
outliers = df[(df[attribute] < lower_bound) | (df[attribute] > upper_bound)][attribute]
print(f"\nOutliers for {attribute}:")
print(outliers)
print(f"Thresholds for Outliers in {attribute}:")
print(f"  Lower Bound: {lower_bound}")
print(f"  Upper Bound: {upper_bound}")

"""Q13)Write a script to overlay another dataset (e.g., population
density or income levels) on the existing choropleth map to provide
more context for the data being visualized. How does the additional data
change the insights from the map?
"""

import geopandas as gpd
import plotly.express as px
japan_geo = 'japan.geojson'
gdf = gpd.read_file(japan_geo)
gdf.nam = gdf.nam.str.split().str[0]
merged_data = gdf.merge(df, left_on='nam', right_on='Prefecture', how='inner')
from google.colab import drive
drive.mount('/content/drive')
# Plot the geographical visualization using Plotly
fig = px.choropleth_mapbox(
    merged_data,
    geojson=merged_data.geometry,
    locations=merged_data.index,
    color='Life_expectancy',
    color_continuous_scale='viridis',
    mapbox_style='carto-positron',
    hover_name='Prefecture',
    hover_data=[ 'Life_expectancy', 'Physician', 'Junior_col',
       'University', 'Public_Hosp', 'Pshic_hosp', 'Beds_psic', 'Nurses',
       'Avg_hours', 'Salary', 'Elementary_school', 'Sport_fac', 'Park',
       'Forest', 'Income_per capita', 'Density_pop', 'Hospitals', 'Beds',
       'Ambulances', 'Health_exp', 'Educ_exp', 'Welfare_exp'],  # Add more columns to display in the hover tooltip
    center={'lat': 36, 'lon': 138},
    zoom=4.5,
    opacity=0.7,
    labels={'Life_expectancy': 'Life Expectancy'}
)
# Update the map layout to add a title, adjust margins, and show the legend
fig.update_layout(
    title_text='Life Expectancy in Japan by Prefecture: Hover on the map to see detailed information',
    margin={'r': 20, 't': 40, 'l': 20, 'b': 0},
    legend=dict(title='Life Expectancy'),
)
# Show the interactive plot
fig.show()